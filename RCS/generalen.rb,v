head	1.1;
access;
symbols;
locks
	nili:1.1; strict;
comment	@# @;


1.1
date	2005.11.09.20.16.15;	author nili;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#! /usr/bin/env ruby
# -*- coding: iso-8859-1 -*-

require 'logger'
require 'monitor'
require 'pp'
require 'pstore'
require 'readline'

require 'kom'
require 'prefix_words_matches'
require 'swedish'
require 'view'

######################################################################

class KomBot
  include Kom

  def initialize(params = {})
    @@params = {
      :unix_user => 'kom.rb',
      :port => 4894,
      :client_name => 'KomBot.rb',
      :client_version => '0.1.0',
      :invisible => 1 }.merge(params)
  end
  def run
    @@conn = CachedConnection.new(@@params[:server],
                                 @@params[:port],
                                 @@params[:unix_user])
    ReqLogin.new(@@conn,
                 @@params[:person],
                 @@params[:password],
                 @@params[:invisible]).response
    ReqSetClientVersion.new(@@conn,
                            @@params[:client_name],
                            @@params[:client_version])

    async_callbacks = []
    methods.each do |m|
      begin
        if Kom.const_defined? m.upcase
          async = Kom.const_get(m.upcase)
          @@conn.add_async_handler(async, method(m))
          async_callbacks << async
        end
      rescue NameError
      end
    end
    ReqAcceptAsync.new(@@conn, async_callbacks).response

    loop do
      data = select([@@conn.socket], [], [], @@params[:periodic_timeout])
      if data
        @@conn.parse_present_data()
      else
        periodic
      end
    end
  end

  def send_message(person, msg)
    m = msg
    while not m.empty?
      part = m.slice!(0...8000)
      ReqSendMessage.new(@@conn, person, part).response
    end
  end

  def conf_name(number)
    @@conn.conf_name(number)
  end

  private

  def periodic
  end
end

######################################################################

class Generalen < KomBot
  def initialize(params = {})
    super(params.merge({ :unix_user => 'generalen',
                         :client_name => 'generalen.rb',
                         :client_version => '0.1.0',
                         :periodic_timeout => 10 }))
  end

  def async_send_message(msg, c)
    if msg.recipient == @@params[:person]
      $logger.info "send_message %s" % [c.conf_name(msg.sender)]
      $state.command(msg.sender, msg.message)
    end
  end

  def async_login(msg, c)
    $state.command(msg.person_no, :login)
  end

end

######################################################################

class Person
  attr_reader :messages
  def initialize(id)
    @@id = id
    @@messages = []
    @@games = []
    @@current_game = nil
  end
  def all_messages
    @@messages.collect{|m|m.strip}.join "\n\n"
  end
  def post(message)
    @@messages << message
  end
  def go_to_game(game)
    if not @@games.include? game
      raise KeyError
    end
    if game != @@current_game and @@current_game != nil
      post 'Du är nu aktiv i %s.' % game.name
    end
    @@current_game = game
  end
  def name
    if @@id == :admin
      "Administratören"
    else
      $kombot.conf_name(@@id)
    end
  end
  def long_name
    if @@id == :admin
      'Administratören'
    else
      '<person %p: %s>' % [@@id, name]
    end
  end

  def help(words = nil)
    text = "Jag leder partier av ett spel inte helt olikt Risk.\n\nFraser jag potentiellt begriper:\n"
    phrases = ["status", "nytt spel [SPEL]", "deltag [SPEL]", "börja", "kort", "placera",
      "anfall","flytta", "klar", "lämna", "kapitulera", "karta [namn]", "gränser", "säg TEXT", "elisphack"].sort
    text << phrases.column_list_view
    text << "\n\nNamn och fraser går att kom-förkorta varhelst man vill."
    text << "\n\nFramför klagomål till <person 9023: Nicklas Lindgren (Äter mopeder, öppnar kasino)>\n\nGurk. Ost."
    post text
  end
  def elisphack(words = nil)
    text = "Praktiska saker för elisp-klienten:\n\n"
    text << "Bind s g till att sända ett meddelande till mig:\n"
    text << "  (add-hook 'lyskom-mode-hook (lambda () (local-set-key [?s ?g] (lambda nil (interactive) (kom-send-message 12668)))))"
    post text
  end
  def new_game(words = nil)
    g = $state.new_game(words)
    g.add_person(self)
    @@games << g
    post "Du har skapat %s." % g.name
    go_to_game(g)
  end
  def go_to(words = nil)
    post @@games.name_hash
  end

  def status(words = nil)
    if @@games.empty?
      post 'Du deltar inte i några partier.'
    else
      other_games = @@games.reject{|g|g==@@current_game}
      post "Du är aktiv i:\n  " + @@current_game.name if @@current_game
      post "Du deltar också i:\n" + other_games.names.sort.list_view if not other_games.empty?
    end
    post $state.status
  end
  def statistik(words)
    raise CommandError.new('Oimplementerat')
  end
  def info(words)
    raise CommandError.new('Oimplementerat')
  end
end

######################################################################

class Player
  def initialize(game, person)
    @@game = game
    @@person = person
  end
end

######################################################################

class Game
  attr_reader :name
  attr_reader :started
  attr_reader :ended
  attr_reader :round
  def initialize(name)
    @@name = name
    @@players = []
  end
  def brief_status
    result = "  %s\n" % @@name
    @@players.each do |person, player|
      result << "   | %s\n" % person.long_name
    end
    result
  end
  def player(person)
    @@players.assoc(person)
  end
  def max_players
    6
  end
  def add_person(person)
    if @@players.length >= max_players
      raise CommandError.new('%s är fullt!' % name)
    else
      player = Player.new(self, person)
      @@players << [person, player]
      post_to_everybody_except(person, '%s har gått med i %s.' % [ person.name, name ])
    end
  end
  def people
    @@players.collect { |person, player| person }
  end
  def players
    @@players.collect { |person, player| player }
  end
  def post_to_everybody(message)
    people.each do |person|
      person.post message
    end
  end
  def post_to_everybody_except(person, message)
    people.reject{|p| p == person}.each do |p|
      p.post message
    end
  end
end

######################################################################

class CommandError < RuntimeError; end

class State < Monitor
  def initialize
    @@store = PStore.new('generalen.state')
    @@store.transaction do
      if not @@store[:inited]
        @@store[:people] = {}
        @@store[:games] = []
        @@store[:last_game_number] = 0
        @@store[:inited] = true
      end
    end
    super
  end

  Commands = ({ ['elisphack'] => :elisphack,
                ['nytt', 'spel'] => :new_game,
                ['deltag', 'i'] => :join,
                ['gå', 'till'] => :go_to,
                ['status'] => :status,
                ['lämna'] => :leave,
                ['kapitulera'] => :surrender,
                ['statistik'] => :statistik,
                ['information'] => :statistik,
                ['information', 'om'] => :info })

  def command(from_person, cmd)
    synchronize do
      @@store.transaction do
        if cmd == :login
          if @@store[:people].has_key?(from_person)
            flush
          end
          return
        end
        words = cmd.strip.split
        return if words.empty?
        person = get_person(from_person)

        alts = Commands.prefix_words_matches(words)
        if alts.empty?
          person.help
        elsif alts.length > 1
          person.post "Du kanske menar något av följande:\n" + alts.collect{ |a| a.first.join(' ') }.sort.column_list_view
        else
          begin
            person.send(Commands[alts[0].first], words[alts[0].last..-1])
          rescue CommandError => e
            person.post e.message
          end
        end

        flush
      end
    end
  end

  def new_game(name_words = nil)
    @@store[:last_game_number] += 1
    if not name_words or name_words.empty?
      name = @@store[:last_game_number].swedish(:ordinal => true).capitalize + ' partiet'
    else
      name = name_words.join(' ')
    end
    g = Game.new(name)
    @@store[:games] << g
    g
  end

  def status
    not_started = @@store[:games].select { |g| not g.started }
    started = @@store[:games].select { |g| g.started and not g.ended }
    ended = @@store[:games].select { |g| g.ended }
    result = []

    if not_started.empty?
      result << 'Det finns inga öppna spel. Prova med "nytt spel"!'
    else
      result << "Öppna spel:\n" + not_started.collect{|g| g.brief_status}.join
    end
    if not started.empty?
      result << "Påbörjade spel:\n" + started.collect{|g| g.brief_status}.join
    end
    if not ended.empty?
      result << "Nyligen avslutade spel:\n" + not_started.collect{|g| g.brief_status}.join
    end
    result.join "\n\n"
  end

  private

  def flush
    @@store[:people].each do |id, person|
      next if person.messages.empty?
      if id == :admin
        puts "\n"
        puts person.all_messages
        person.messages.clear
      else
        if $kombot
          begin
            $kombot.send_message(id, person.all_messages)
          rescue Kom::MessageNotSent
          else
            person.messages.clear
          end
        end
      end
    end
  end

  def get_person(person_id)
    person = @@store[:people][person_id]
    if not person
      person = @@store[:people][person_id] = Person.new(person_id)
    end
    person
  end

end

######################################################################

$logger = Logger.new('generalen.log', 10, 1024**2)
$state = State.new

Thread.abort_on_exception = true

begin
  kom_thread = Thread.new do
    loop do
      begin
        cmd = Readline.readline('generalen> ', true)
        if cmd and not cmd.empty?
          if cmd =~ (/^:/)
            pp eval(cmd[1..-1])
          else
            $state.command(:admin, cmd)
          end
        end
      rescue Exception => e
        puts e
      end
    end
  end
  $kombot = Generalen.new(:server => 'kom.lysator.liu.se',
                          :person => 12668,
                          :password => '64llob')
  $kombot.run
  kom_thread.join
rescue Interrupt
  puts
end
@
